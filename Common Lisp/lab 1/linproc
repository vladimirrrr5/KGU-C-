;; Основный цикл работы LISP машины. (f ....) -фцнкция, вводимая изс консоли.
;;(print(eval(read (f.....))))

;; Поэтому при вызове функции print из консоли печать сработает дважды.

(print " Ghbdtn ctvm  t")

" Ghbdtn ctvmt"
" Ghbdtn ctvmt"

"Линейная последовательность согласованных вызовов функций.

X = Y+1;
Z = X-10;
W = X/Y;
V = W*Z;
Все промежуточные значения должны быть выведены на экран.

Функции:
fx(Y),
fz(X),
fw(X,Y),
fv(W,Z).
"
(defun fx(Y)
  (+ Y 1)
  )
(defun fz(X)
  (- X 10)
  )
(defun fw(X Y)
  (/ X Y)
  )
(defun fv(W Z)
  (* W Z)
  )
" Функция, разработанная без тестирования без ошибок синтаксиса"
(defun result(Y)
  (list (fx Y)                                ;X = Y+1;
	(fz (fx Y))                           ;Z = X-10;
        (fw (fz (fx Y)) Y)                    ;W = X/Y;
	(fv (fw (fz (fx Y)) Y) (fz (fx Y)) )));V = W*Z;.
		




		
" Тест.
Функция result.
Вход: Y=1.Далее считается вручную.
X=2,
Z=-8,
W=-8,
V=64.
Выход:(result 1)-> (2 -8 -8 64)"

"Если подставить на место фактического аргумета в вызове функции (fz  фактический_аргумент ) вызов функции (fx Y)и получить
      (fz (fx Y)), то при взаимодействии вызова функции fz  с ее определениемм
(defun fz (X   )
  (- X 10)
  )
 формальному аргументу X будет присвоенно вычисленной значение функции fx,
 которое затем будет использоваться везде внутри тела функции

(defun fz (X   )

  ;: тело функции fz

  )



 везде, где встретится X.
Вне тела функции этого значение не сохраняется."

"Последовательость разработки.
Общая схема вычисления функции result(Y)кончтруируется и отлаживается последоваельно по частям. 
(defun result(Y)
  (list (fx ... );X = Y+1; (defun fx(Y)  (+ Y 1)  )
	;(fz ... );Z = X-10;(defun fz(X)  (- X 10)  )
        ;(fw ...);W = X/Y;(defun fw(X Y)  (/ X Y)  )
	;(fv ...);V = W*Z;(defun fv(W Z)  (* W Z)  ).
	))


"
" Первый шаг."

(defun result(Y)
  (list (fx Y);X = Y+1; (defun fx(Y)  (+ Y 1)  )
	;(fz ...  );Z = X-10;(defun fz(X)  (- X 10)  )
        ;(fw ... );W = X/Y;(defun fw(X Y)  (/ X Y)  )
	;(fv ...);V = W*Z;(defun fv(W Z)  (* W Z)  ).
	))
 ;;;Проверка

" Второй шаг."

(defun result(Y)
  (list (fx Y)      ;X = Y+1; (defun fx(Y)  (+ Y 1)  )
	(fz (fx Y))  ;Z = X-10;(defun fz(X)  (- X 10)  )
        ;(fw ... )  ;W = X/Y;(defun fw(X Y)  (/ X Y)  )
	;(fv ...)   ;V = W*Z;(defun fv(W Z)  (* W Z)  ).
	))
 ;;;Проверка
;(result 1)
;(2 -8)
" Третий шаг."

(defun result(Y)
  (list (fx Y)                 ;X = Y+1; (defun fx(Y)  (+ Y 1)  )
	(fz (fx Y))            ;Z = X-10;(defun fz(X)  (- X 10)  )
        (fw (fx Y) (fz (fx Y)));W = X/Y;(defun fw(X Y)  (/ X Y)  )
	;(fv ...)   ;V = W*Z;(defun fv(W Z)  (* W Z)  ).
	))
 ;;;Проверка
;(result 1)
;(2 -8 0)
"Ошибка. Вместо Y подставили Z."

(defun result(Y)
  (list (fx Y)                 ;X = Y+1; (defun fx(Y)  (+ Y 1)  )
	(fz (fx Y))            ;Z = X-10;(defun fz(X)  (- X 10)  )
        (fw (fx Y)Y );W = X/Y;(defun fw(X Y)  (/ X Y)  )
	;(fv ...)   ;V = W*Z;(defun fv(W Z)  (* W Z)  ).
	))
 ;;;Проверка
;(result 1)
;(2 -8 2)
"С тестом не совпадает.Должно быть (2 -8 -8). В чем дело?"



" Четвертый шаг."
(defun result(Y)
  (list (fx Y)                       ;X = Y+1; (defun fx(Y)  (+ Y 1)  )
	(fz (fx Y))                  ;Z = X-10;(defun fz(X)  (- X 10)  )
        (fw (fx Y)Y )                ;W = X/Y;(defun fw(X Y)  (/ X Y)  )
	(fv (fw (fx Y)Y )(fz (fx Y)));V = W*Z;(defun fv(W Z)  (* W Z)  ).
	))
 ;;;Проверка
;(result 1)
;(2 -8 2 -16)
"С тестом не совпадает. Должно быть (2 -8 -8 64). В чем дело?"

"Детальный анализ показал, что функция, разработанная сразу вся :
 
(defun result(Y)
  (list (fx Y)                                ;X = Y+1;
	(fz (fx Y))                           ;Z = X-10;
        (fw (fz (fx Y)) Y)                    ;W = X/Y;
	(fv (fw (fz (fx Y)) Y) (fz (fx Y)) )));V = W*Z;.
		
(result 1)
(2 -8 -8 64)

Вычисляет не W = X/Y; , а W = Z/Y;. А тест подогнан под результат вычисления при запуске функции.
Правильный (валидный) тест следующий:
Тест.
Функция result.
Вход: Y=1.Далее считается вручную.
X=2,
Z=-8,
W=2,
V=-16.
Выход:(result 1)-> (2 -8 2 -16)
Отсюда следует, что разработнаная в пошаговом варианте функция один валидный тест прошла.
Но сказать, что она правильно работает нельзя. Необходимо обоснованное тестирование, которое не проводилось."